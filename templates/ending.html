{% extends "layouts/base.html" %}

{% block head %}
<title>Ending Page</title>
{% endblock %}

{% block style %}
<style>
    .ending-container {
        max-width: 1100px;
        margin: 30px auto;
        padding: 24px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 16px;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.12);
    }
    .badge-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: #f5f5f7;
        border: 1px solid #e0e0e0;
        border-radius: 999px;
        padding: 6px 14px;
        margin: 6px;
        font-weight: 600;
    }
    .code-box {
        background: #0b1020;
        color: #d4d7ff;
        border-radius: 12px;
        padding: 16px;
    }
    .code-box pre {
        margin: 0;
        white-space: pre-wrap;
    }
    .status-pill {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 700;
    }
    .status-ok {
        background: #d1fae5;
        color: #065f46;
    }
    .status-bad {
        background: #fee2e2;
        color: #991b1b;
    }
    .guide-panel {
        background: #0f172a;
        color: #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        min-height: 160px;
    }
    .guide-progress {
        height: 6px;
        background: rgba(148, 163, 184, 0.3);
        border-radius: 999px;
        overflow: hidden;
        margin-bottom: 12px;
    }
    .guide-progress > div {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #38bdf8, #22d3ee);
        transition: width 0.3s ease;
    }
    .guide-step {
        padding: 8px 10px;
        border-radius: 10px;
        margin-bottom: 8px;
        background: rgba(148, 163, 184, 0.12);
    }
    .guide-step.active {
        background: rgba(56, 189, 248, 0.25);
        border: 1px solid rgba(56, 189, 248, 0.6);
    }
    .guide-visuals {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 10px;
        margin-top: 12px;
    }
    .guide-visual-card {
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        padding: 10px;
    }
    .guide-visual-card .emoji {
        font-size: 20px;
        margin-right: 6px;
    }
    .guide-visual-card img {
        width: 100%;
        border-radius: 10px;
        margin-top: 8px;
        border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .guide-video {
        margin-top: 12px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(30, 41, 59, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.35);
    }
    .guide-video-output {
        margin-top: 12px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.35);
    }
    .guide-video-output video {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: #0b1020;
    }
    .video-fallback {
        color: #cbd5f5;
        font-size: 14px;
        margin-top: 8px;
    }
    .video-scene {
        padding: 8px 10px;
        border-radius: 10px;
        margin-bottom: 8px;
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid transparent;
    }
    .video-scene.active {
        background: rgba(56, 189, 248, 0.2);
        border: 1px solid rgba(56, 189, 248, 0.6);
    }
    .guide-ui-steps {
        margin-top: 12px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(34, 211, 238, 0.12);
        border: 1px solid rgba(34, 211, 238, 0.4);
    }
    .chat-box {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 12px;
        max-height: 260px;
        overflow-y: auto;
        background: #fafafa;
    }
    .helper-text {
        color: #64748b;
        font-size: 14px;
        margin-bottom: 6px;
    }
    .role-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
    }
    .role-badge {
        border: 1px solid #2563eb;
        background: transparent;
        color: #2563eb;
        border-radius: 999px;
        padding: 6px 12px;
        font-weight: 600;
        font-size: 13px;
    }
    .role-badge.active {
        background: #2563eb;
        color: #fff;
    }
    .chat-panel {
        border: 1px solid #1f2937;
        border-radius: 12px;
        background: #0b1020;
        color: #e2e8f0;
        padding: 12px;
    }
    .chat-log {
        max-height: 220px;
        overflow-y: auto;
        margin-bottom: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .chat-bubble {
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 14px;
    }
    .chat-ai {
        background: rgba(56, 189, 248, 0.2);
        border: 1px solid rgba(56, 189, 248, 0.4);
    }
    .chat-user {
        align-self: flex-end;
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid rgba(59, 130, 246, 0.4);
    }
    .chat-input {
        display: flex;
        gap: 8px;
    }
    .chat-input input {
        flex: 1;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: #0f172a;
        color: #e2e8f0;
    }
    .chat-message {
        margin-bottom: 10px;
    }
    .chat-user {
        font-weight: 600;
        color: #1f2937;
    }
    .chat-ai {
        font-weight: 600;
        color: #2563eb;
    }
</style>
{% endblock %}

{% block body %}
<div class="ending-container">
    <div class="d-flex flex-wrap justify-content-between align-items-center mb-4">
        <div>
            <h2 class="mb-1">Maze Complete</h2>
            <div class="text-muted">Player ID: {{ player_id }}</div>
        </div>
        <div id="completionStatus" class="status-pill status-bad">Not Completed</div>
    </div>

    <div class="row g-4">
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-body">
                    <h5 class="card-title">Final Score Summary</h5>
                    <div class="row">
                        <div class="col-6">
                            <div class="text-muted">Final Attempts</div>
                            <div id="finalAttempts" class="h4">-</div>
                        </div>
                        <div class="col-6">
                            <div class="text-muted">Final Badge</div>
                            <div id="finalBadge" class="h4">-</div>
                        </div>
                    </div>
                    <div class="mt-3">
                        <div class="text-muted">Completed At</div>
                        <div id="completedAt">-</div>
                    </div>
                    <div class="mt-3">
                        <div class="text-muted">Final Answer Correct</div>
                        <div id="finalCorrect">-</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-body">
                    <h5 class="card-title">Earned Badges</h5>
                    <div id="badgeList" class="mt-2">Loading...</div>
                </div>
            </div>
        </div>

        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Attempts & Timestamps</h5>
                    <div class="table-responsive">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>Badge</th>
                                    <th>Attempts</th>
                                    <th>Timestamp</th>
                                </tr>
                            </thead>
                            <tbody id="attemptsTable">
                                <tr><td colspan="3">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Final Code Answer</h5>
                    <div class="row g-3 mb-3">
                        <div class="col-md-3">
                            <label class="form-label">Final Attempts</label>
                            <input id="finalAttemptsInput" type="number" class="form-control" min="0" placeholder="e.g. 3">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Final Badge Name</label>
                            <input id="finalBadgeInput" type="text" class="form-control" placeholder="e.g. Champion">
                        </div>
                    </div>
                    <textarea id="finalAnswer" class="form-control" rows="6" placeholder="Paste your final code here..."></textarea>
                    <div class="d-flex flex-wrap gap-2 mt-3">
                        <button id="checkAnswer" class="btn btn-primary">Check Answer</button>
                        <button id="saveCompletion" class="btn btn-success">Save Completion</button>
                        <div id="checkStatus" class="ms-auto"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">AI Walkthrough Video (No Full Code)</h5>
                    <p class="text-muted">Generate a step-by-step video walkthrough that explains how the code is written, without revealing the full solution.</p>
                    <div class="d-flex flex-wrap gap-2 mb-3">
                        <button id="generateGuide" class="btn btn-outline-primary">Generate Video Walkthrough</button>
                        <button id="playGuide" class="btn btn-outline-secondary">Play Video</button>
                        <span id="guideStatus" class="text-muted"></span>
                    </div>
                    <div class="guide-panel" id="guidePanel">
                        <div class="guide-progress"><div id="guideProgress"></div></div>
                        <div class="text-muted">No walkthrough generated yet.</div>
                    </div>
                    <div class="guide-video-output" id="guideVideoOutput" style="display:none;">
                        <div class="d-flex flex-wrap justify-content-between align-items-center mb-2">
                            <strong>Generated Video</strong>
                            <a id="downloadVideo" class="btn btn-sm btn-outline-light" download="walkthrough.webm" href="#">Download</a>
                        </div>
                        <video id="guideVideoPlayer" controls></video>
                        <div id="videoFallback" class="video-fallback" style="display:none;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <h3>üí¨ Hint Coach Chatbot</h3>
                    <p class="helper-text">Pick a helper role so you get the right type of code answer.</p>
                    <p class="helper-text">Guardrail: The chatbot replies with Python code only (no explanations).</p>
                    <div class="role-badges" id="chatRoles">
                        <button type="button" class="role-badge" data-role="hint">Hint Coach</button>
                        <button type="button" class="role-badge" data-role="debugger">Debugger</button>
                        <button type="button" class="role-badge" data-role="teacher">Teacher</button>
                        <button type="button" class="role-badge" data-role="checker">Checker</button>
                    </div>
                    <div class="chat-panel">
                        <div class="chat-log" id="chatLog">
                            <div class="chat-bubble chat-ai">Hint Coach: Tell me the level and what you think the bug is.</div>
                        </div>
                        <div class="chat-input">
                            <input id="chatInput" type="text" placeholder="Ask a question and get code-only replies" />
                            <button class="btn btn-primary" id="sendChat">Send</button>
                        </div>
                        <div class="mt-3">
                            <label class="form-label">Run Python code</label>
                            <textarea id="codeRunnerInput" class="form-control" rows="4" placeholder="Paste Python code here to run..."></textarea>
                            <div class="d-flex gap-2 mt-2">
                                <button type="button" class="btn btn-outline-primary" id="runCode">Run Code</button>
                                <span class="text-muted" id="codeRunStatus"></span>
                            </div>
                            <div class="code-box mt-2" id="codeRunOutput" style="display:none;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Data Model Summary</h5>
                    <p class="text-muted mb-0">
                        This game uses a many-to-many relationship between players and badges. One player can earn
                        many different badges, and the same badge can be earned by many different players. That is
                        why a Player Badges table is used: it tracks each earned badge with attempts and timestamps
                        so progress is stored clearly for every student.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="pageData" data-player-id="{{ player_id }}" data-api-base="{{ api_base|default('') }}" hidden></div>

<script>
    const pageData = document.getElementById("pageData");
    const playerId = pageData?.dataset.playerId;
    const apiBase = (pageData?.dataset.apiBase || "").replace(/\/$/, "");

    const badgeList = document.getElementById("badgeList");
    const attemptsTable = document.getElementById("attemptsTable");
    const completionStatus = document.getElementById("completionStatus");

    const finalAttempts = document.getElementById("finalAttempts");
    const finalBadge = document.getElementById("finalBadge");
    const completedAt = document.getElementById("completedAt");
    const finalCorrect = document.getElementById("finalCorrect");

    const finalAnswerInput = document.getElementById("finalAnswer");
    const finalAttemptsInput = document.getElementById("finalAttemptsInput");
    const finalBadgeInput = document.getElementById("finalBadgeInput");
    const checkAnswerBtn = document.getElementById("checkAnswer");
    const saveCompletionBtn = document.getElementById("saveCompletion");
    const checkStatus = document.getElementById("checkStatus");
    const generateGuideBtn = document.getElementById("generateGuide");
    const playGuideBtn = document.getElementById("playGuide");
    const guidePanel = document.getElementById("guidePanel");
    const guideStatus = document.getElementById("guideStatus");
    const guideProgress = document.getElementById("guideProgress");
    const guideVideoOutput = document.getElementById("guideVideoOutput");
    const guideVideoPlayer = document.getElementById("guideVideoPlayer");
    const downloadVideo = document.getElementById("downloadVideo");
    const videoFallback = document.getElementById("videoFallback");
    const chatLog = document.getElementById("chatLog");
    const chatInput = document.getElementById("chatInput");
    const chatSend = document.getElementById("sendChat");
    const chatRoles = Array.from(document.querySelectorAll(".role-badge"));
    const codeRunnerInput = document.getElementById("codeRunnerInput");
    const runCodeBtn = document.getElementById("runCode");
    const codeRunStatus = document.getElementById("codeRunStatus");
    const codeRunOutput = document.getElementById("codeRunOutput");
    const chatHistory = [];
    let chatRole = "hint_coach";
    let guideSteps = [];
    let guideDurations = [];
    let guideVideo = null;
    let guideUiSteps = [];
    let guideVideoNotice = "";
    let guideVideoBlobUrl = "";

    function appendChatVideo(url) {
        if (!chatBox || !url) return;
        const wrapper = document.createElement("div");
        wrapper.className = "chat-message";
        wrapper.innerHTML = `
            <div class="chat-ai">AI</div>
            <video controls style="max-width:100%; border-radius:10px; margin-top:6px;">
                <source src="${url}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
        `;
        chatBox.appendChild(wrapper);
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    function setGuideVideoUrl(url) {
        if (!url) return;
        if (guideVideoBlobUrl) {
            URL.revokeObjectURL(guideVideoBlobUrl);
            guideVideoBlobUrl = "";
        }
        if (guideVideoPlayer) {
            guideVideoPlayer.src = url;
        }
        if (downloadVideo) {
            downloadVideo.href = url;
        }
        if (guideVideoOutput) {
            guideVideoOutput.style.display = "block";
        }
        if (videoFallback) {
            videoFallback.style.display = "none";
        }
    }

    function formatTimestamp(ts) {
        if (!ts) return "-";
        const date = new Date(ts);
        return date.toLocaleString();
    }

    async function safeFetch(path, options = {}) {
        try {
            const response = await fetch(`${apiBase}${path}`, options);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response;
        } catch (error) {
            console.error("Backend request failed:", error);
            return null;
        }
    }

    function renderScore(data) {
        const earnedBadges = data.earned_badges || [];
        badgeList.innerHTML = earnedBadges.length
            ? earnedBadges.map(b => `<span class="badge-pill">üèÖ ${b.badge_name}</span>`).join("")
            : "No badges earned yet.";

        attemptsTable.innerHTML = earnedBadges.length
            ? earnedBadges.map(b => `
                <tr>
                    <td>${b.badge_name || "-"}</td>
                    <td>${b.attempts}</td>
                    <td>${formatTimestamp(b.timestamp)}</td>
                </tr>
            `).join("")
            : '<tr><td colspan="3">No attempts logged yet.</td></tr>';

        const finalData = data.final || {};
        finalAttempts.textContent = finalData.final_attempts ?? "-";
        finalBadge.textContent = finalData.final_badge?.badge_name || "-";
        completedAt.textContent = formatTimestamp(finalData.completed_at);
        finalCorrect.textContent = typeof finalData.final_correct === "boolean"
            ? (finalData.final_correct ? "Yes" : "No")
            : "-";

        if (finalAttemptsInput && finalData.final_attempts !== null && finalData.final_attempts !== undefined) {
            finalAttemptsInput.value = finalData.final_attempts;
        }
        if (finalBadgeInput && finalData.final_badge?.badge_name) {
            finalBadgeInput.value = finalData.final_badge.badge_name;
        }

        if (data.completion_status) {
            completionStatus.textContent = "Completed";
            completionStatus.classList.remove("status-bad");
            completionStatus.classList.add("status-ok");
        } else {
            completionStatus.textContent = "Not Completed";
            completionStatus.classList.remove("status-ok");
            completionStatus.classList.add("status-bad");
        }
    }

    async function loadScore() {
        if (!playerId) {
            badgeList.textContent = "Missing player id";
            attemptsTable.innerHTML = '<tr><td colspan="3">Missing player id</td></tr>';
            return;
        }
        const response = await safeFetch(`/player/${playerId}/score`);
        if (!response) {
            badgeList.textContent = "Backend unavailable";
            attemptsTable.innerHTML = '<tr><td colspan="3">Backend unavailable</td></tr>';
            return;
        }
        const data = await response.json();
        if (data.success) {
            renderScore(data);
        }
    }

    checkAnswerBtn.addEventListener("click", async () => {
        checkStatus.textContent = "Checking...";
        const response = await safeFetch(`/player/${playerId}/final-check`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ answer: finalAnswerInput.value })
        });
        if (!response) {
            checkStatus.textContent = "Backend unavailable";
            return;
        }
        const data = await response.json();
        if (data.correct) {
            checkStatus.textContent = "‚úÖ Correct answer";
            const badgeResponse = await safeFetch(`/player/${playerId}/final-badge`, {
                method: "POST",
                headers: { "Content-Type": "application/json" }
            });
            if (!badgeResponse) {
                checkStatus.textContent = "‚úÖ Correct answer (badge pending)";
            }
        } else {
            checkStatus.textContent = "‚ùå Incorrect answer";
            if (Array.isArray(data.steps) && data.steps.length) {
                guideSteps = data.steps;
                guideVideo = null;
                guideUiSteps = [];
                guideVideoNotice = "";
                renderGuideSteps(guideSteps, "Fix Steps");
            }
        }
        await loadScore();
    });

    function renderGuideSteps(steps, title = "Walkthrough") {
        if (!guidePanel) return;
        if (!steps || !steps.length) {
            guidePanel.innerHTML = "<div class=\"text-muted\">No steps available yet.</div>";
            return;
        }
        const videoNoticeHtml = guideVideoNotice
            ? `<div class=\"text-warning mt-2\" style=\"font-size: 13px;\">${guideVideoNotice}</div>`
            : "";
        const videoHtml = guideVideo && Array.isArray(guideVideo.scenes) && guideVideo.scenes.length
            ? `
                <div class=\"mt-3\"><strong>${guideVideo.title || "Step-by-step Video"}</strong></div>
                <div class=\"guide-video\">
                    ${guideVideo.scenes.map((scene, idx) => `
                        <div class=\"video-scene\" data-scene=\"${idx}\">
                            <div><strong>${scene.title || `Scene ${idx + 1}`}</strong></div>
                            <div class=\"text-muted\" style=\"font-size: 13px;\">${scene.on_screen || scene.narration || ""}</div>
                        </div>
                    `).join("")}
                </div>
            `
            : "";
        const uiStepsHtml = Array.isArray(guideUiSteps) && guideUiSteps.length
            ? `
                <div class=\"guide-ui-steps\">
                    <div class=\"mb-1\"><strong>UI Step-by-Step</strong></div>
                    <ol class=\"mb-0\">
                        ${guideUiSteps.map(step => `<li>${step}</li>`).join("")}
                    </ol>
                </div>
            `
            : "";
        guidePanel.innerHTML = `
            <div class=\"guide-progress\"><div id=\"guideProgress\"></div></div>
            <div class=\"mb-2\"><strong>${title}</strong></div>
            ${steps.map((step, index) => `
                <div class=\"guide-step\" data-step=\"${index}\">
                    ${index + 1}. ${step}
                </div>
            `).join("")}
            ${uiStepsHtml}
            ${videoNoticeHtml}
            ${videoHtml}
        `;
    }

    function resetVideoOutput() {
        if (guideVideoBlobUrl) {
            URL.revokeObjectURL(guideVideoBlobUrl);
            guideVideoBlobUrl = "";
        }
        if (guideVideoPlayer) {
            guideVideoPlayer.src = "";
        }
        if (downloadVideo) {
            downloadVideo.href = "#";
        }
        if (videoFallback) {
            videoFallback.textContent = "";
            videoFallback.style.display = "none";
        }
        if (guideVideoOutput) {
            guideVideoOutput.style.display = "none";
        }
    }

    function drawScene(ctx, width, height, scene, progress) {
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = "#0b1020";
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = "#38bdf8";
        ctx.fillRect(40, 40, Math.max(0, (width - 80) * progress), 8);

        ctx.fillStyle = "#e2e8f0";
        ctx.font = "bold 28px sans-serif";
        ctx.fillText(scene.title || "Step", 40, 100);

        ctx.fillStyle = "#cbd5f5";
        ctx.font = "20px sans-serif";
        const text = scene.onScreen || scene.narration || "";
        const maxWidth = width - 80;
        const words = text.split(" ");
        let line = "";
        let y = 150;
        words.forEach(word => {
            const testLine = line + word + " ";
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && line) {
                ctx.fillText(line.trim(), 40, y);
                line = word + " ";
                y += 28;
            } else {
                line = testLine;
            }
        });
        if (line) ctx.fillText(line.trim(), 40, y);

        ctx.fillStyle = "rgba(56, 189, 248, 0.2)";
        ctx.fillRect(40, height - 80, width - 80, 40);
        ctx.fillStyle = "#e2e8f0";
        ctx.font = "16px sans-serif";
        ctx.fillText("AI Walkthrough Video", 50, height - 53);
    }

    async function generateVideoFromScenes(scenes) {
        if (!window.MediaRecorder) {
            guideStatus.textContent = "Video generation not supported in this browser";
            if (guideVideoOutput) guideVideoOutput.style.display = "block";
            if (videoFallback) {
                videoFallback.textContent = "Your browser does not support MediaRecorder. Use the step list instead.";
                videoFallback.style.display = "block";
            }
            return;
        }
        resetVideoOutput();

        if (guideVideoOutput) {
            guideVideoOutput.style.display = "block";
        }
        if (videoFallback) {
            videoFallback.textContent = "Generating video...";
            videoFallback.style.display = "block";
        }

        const canvas = document.createElement("canvas");
        const width = 960;
        const height = 540;
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");

        const stream = canvas.captureStream(30);
        const preferredTypes = [
            "video/webm;codecs=vp9",
            "video/webm;codecs=vp8",
            "video/webm"
        ];
        const mimeType = preferredTypes.find(type => MediaRecorder.isTypeSupported(type)) || "";
        let recorder;
        try {
            recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
        } catch (error) {
            guideStatus.textContent = "Unable to start video recording";
            if (videoFallback) {
                videoFallback.textContent = "Video recording failed to initialize in this browser.";
                videoFallback.style.display = "block";
            }
            return;
        }
        const chunks = [];
        recorder.ondataavailable = event => {
            if (event.data && event.data.size > 0) chunks.push(event.data);
        };

        recorder.start();
        for (let i = 0; i < scenes.length; i += 1) {
            const scene = scenes[i];
            const durationMs = (guideDurations[i] || 8) * 1000;
            const start = performance.now();
            let elapsed = 0;
            while (elapsed < durationMs) {
                const progress = Math.min(1, elapsed / durationMs);
                drawScene(ctx, width, height, scene, progress);
                await new Promise(resolve => requestAnimationFrame(resolve));
                elapsed = performance.now() - start;
            }
        }
        recorder.stop();

        await new Promise(resolve => {
            recorder.onstop = resolve;
        });

        const blob = new Blob(chunks, { type: "video/webm" });
        if (!blob.size) {
            guideStatus.textContent = "Video generation failed";
            if (videoFallback) {
                videoFallback.textContent = "No video data was produced. Try another browser.";
                videoFallback.style.display = "block";
            }
            return;
        }
        guideVideoBlobUrl = URL.createObjectURL(blob);
        if (guideVideoPlayer) {
            guideVideoPlayer.src = guideVideoBlobUrl;
        }
        if (downloadVideo) {
            downloadVideo.href = guideVideoBlobUrl;
        }
        if (guideVideoOutput) {
            guideVideoOutput.style.display = "block";
        }
        if (videoFallback) {
            videoFallback.style.display = "none";
        }
    }

    generateGuideBtn.addEventListener("click", async () => {
        guideStatus.textContent = "Generating...";
        const response = await safeFetch(`/player/${playerId}/guidance`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ answer: finalAnswerInput.value })
        });
        if (!response) {
            guideStatus.textContent = "Backend unavailable";
            return;
        }
        const data = await response.json();
        if (data.success) {
            guideSteps = data.steps || [];
            guideDurations = Array.isArray(data.durations) ? data.durations : [];
            guideVideo = data.video || null;
            guideUiSteps = Array.isArray(data.ui_steps) ? data.ui_steps : [];
            guideVideoNotice = data.video_notice || "";
            renderGuideSteps(guideSteps, data.title || "Walkthrough");
            if (data.video_url) {
                setGuideVideoUrl(data.video_url);
            } else if (guideVideo && Array.isArray(guideVideo.scenes) && guideVideo.scenes.length) {
                await generateVideoFromScenes(guideVideo.scenes);
            }
            guideStatus.textContent = "";
        } else {
            guideStatus.textContent = data.message || "Unable to generate";
        }
    });

    playGuideBtn.addEventListener("click", () => {
        const hasVideo = guideVideo && Array.isArray(guideVideo.scenes) && guideVideo.scenes.length;
        if (!guideSteps.length && !hasVideo) {
            guideStatus.textContent = "Generate a walkthrough video first";
            return;
        }
        guideStatus.textContent = "Playing...";
        const stepElements = hasVideo
            ? Array.from(document.querySelectorAll(".video-scene"))
            : Array.from(document.querySelectorAll(".guide-step"));
        const progressEl = document.getElementById("guideProgress");
        const playItems = hasVideo
            ? guideVideo.scenes.map(scene => ({
                narration: scene.narration || scene.on_screen || "",
                onScreen: scene.on_screen || scene.narration || ""
            }))
            : guideSteps.map(step => ({ narration: step, onScreen: step }));
        let index = 0;

        function speakNext() {
            if (index >= playItems.length) {
                guideStatus.textContent = "Finished";
                return;
            }
            stepElements.forEach(el => el.classList.remove("active"));
            const activeEl = stepElements[index];
            if (activeEl) activeEl.classList.add("active");

            const durationMs = (guideDurations[index] || 8) * 1000;
            if (progressEl) {
                const percent = Math.min(100, Math.round(((index + 1) / playItems.length) * 100));
                progressEl.style.width = `${percent}%`;
            }

            const utterance = new SpeechSynthesisUtterance(playItems[index].narration);
            utterance.onend = () => {
                index += 1;
                speakNext();
            };
            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);

            setTimeout(() => {
                if (!speechSynthesis.speaking) {
                    index += 1;
                    speakNext();
                }
            }, durationMs);
        }

        speakNext();
    });

    function appendChatMessage(role, text) {
        if (!chatLog) return;
        const bubble = document.createElement("div");
        bubble.className = role === "user" ? "chat-bubble chat-user" : "chat-bubble chat-ai";
        bubble.textContent = role === "user" ? `You: ${text}` : text;
        chatLog.appendChild(bubble);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    function extractPythonCode(text) {
        const match = text.match(/```python\n([\s\S]*?)```/i) || text.match(/```\n([\s\S]*?)```/i);
        if (match) {
            return match[1].trim();
        }
        if (text.trim().toLowerCase().startsWith("run:")) {
            return text.replace(/^run:\s*/i, "").trim();
        }
        return "";
    }

    async function sendChatMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        appendChatMessage("user", message);
        chatHistory.push({ role: "user", content: message });
        chatInput.value = "";
        if (chatSend) chatSend.disabled = true;

        const code = extractPythonCode(message);
        if (code) {
            const response = await safeFetch("/run/python", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ code })
            });
            if (!response) {
                appendChatMessage("assistant", "Run Output: Backend unavailable");
            } else {
                const data = await response.json();
                const output = data.output || "(no output)";
                const verdict = data.is_correct ? "‚úÖ Correct" : "‚ùå Incorrect";
                appendChatMessage("assistant", `Run Output (${verdict}): ${output}`);
                chatHistory.push({ role: "assistant", content: `Run Output (${verdict}): ${output}` });
            }
        }

        const response = await safeFetch(`/player/${playerId}/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message, history: chatHistory, role: chatRole })
        });
        if (!response) {
            appendChatMessage("assistant", "Backend unavailable");
            if (chatSend) chatSend.disabled = false;
            return;
        }
        const data = await response.json();
        const reply = data.reply || data.message || "No response";
        appendChatMessage("assistant", reply);
        chatHistory.push({ role: "assistant", content: reply });
        if (data.video_url) {
            appendChatVideo(data.video_url);
        }
        if (data.guidance && data.guidance.success) {
            guideSteps = data.guidance.steps || [];
            guideDurations = Array.isArray(data.guidance.durations) ? data.guidance.durations : [];
            guideVideo = data.guidance.video || null;
            guideUiSteps = Array.isArray(data.guidance.ui_steps) ? data.guidance.ui_steps : [];
            guideVideoNotice = data.guidance.video_notice || "";
            renderGuideSteps(guideSteps, data.guidance.title || "Walkthrough");
            if (data.guidance.video_url) {
                setGuideVideoUrl(data.guidance.video_url);
            } else if (guideVideo && Array.isArray(guideVideo.scenes) && guideVideo.scenes.length) {
                await generateVideoFromScenes(guideVideo.scenes);
            }
        }
        if (chatSend) chatSend.disabled = false;
    }

    async function runCode() {
        if (!codeRunnerInput) {
            return;
        }
        const code = codeRunnerInput.value.trim();
        if (!code) {
            if (codeRunStatus) codeRunStatus.textContent = "Paste code to run.";
            return;
        }
        if (codeRunStatus) codeRunStatus.textContent = "Running...";
        if (runCodeBtn) runCodeBtn.disabled = true;
        const response = await safeFetch("/run/python", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code })
        });
        if (!response) {
            if (codeRunStatus) codeRunStatus.textContent = "Backend unavailable";
            if (runCodeBtn) runCodeBtn.disabled = false;
            return;
        }
        const data = await response.json();
        const output = data.output || "(no output)";
        const verdict = data.is_correct ? "‚úÖ Correct" : "‚ùå Incorrect";
        if (codeRunOutput) {
            codeRunOutput.style.display = "block";
            codeRunOutput.textContent = `Status: ${verdict}\n\n${output}`;
        }
        if (codeRunStatus) codeRunStatus.textContent = "";
        if (runCodeBtn) runCodeBtn.disabled = false;
    }

    chatSend.addEventListener("click", sendChatMessage);
    chatInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            sendChatMessage();
        }
    });
    if (runCodeBtn) {
        runCodeBtn.addEventListener("click", runCode);
    }
    const roleMap = {
        "hint": "hint_coach",
        "debugger": "debugger",
        "teacher": "teacher",
        "checker": "checker",
    };
    chatRoles.forEach((btn) => {
        btn.addEventListener("click", () => {
            chatRoles.forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
            const rawRole = btn.dataset.role || "hint";
            chatRole = roleMap[rawRole] || "hint_coach";
        });
    });
    if (chatRoles.length) {
        chatRoles[0].classList.add("active");
    }

    saveCompletionBtn.addEventListener("click", async () => {
        checkStatus.textContent = "Saving...";
        const attemptsValue = Number(finalAttemptsInput.value);
        const badgeName = finalBadgeInput.value.trim();
        if (!Number.isFinite(attemptsValue)) {
            checkStatus.textContent = "Enter a valid attempts count";
            return;
        }
        if (!badgeName) {
            checkStatus.textContent = "Enter a badge name";
            return;
        }
        const response = await safeFetch(`/player/${playerId}/complete`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                attempts: attemptsValue,
                badge_name: badgeName,
                timestamp: new Date().toISOString()
            })
        });
        if (!response) {
            checkStatus.textContent = "Backend unavailable";
            return;
        }
        const data = await response.json();
        if (data.success) {
            checkStatus.textContent = "‚úÖ Completion saved";
        } else {
            checkStatus.textContent = data.message || "Error saving completion";
        }
        await loadScore();
    });

    loadScore();
</script>
{% endblock %}
